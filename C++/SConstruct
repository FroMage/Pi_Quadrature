# -*- mode:python; coding:utf-8; -*-

#  Calculation of π using quadrature.
#
#  Copyright © 2008–2013 Russel Winder

import os
import re
import sys
sys.path.append('../site_scons')

from executablesupport import compileTargets, addCompileTarget, runTargets, addRunTarget, executables, createHelp

osName, _, _, _, platformVersion = os.uname()
platformVersion = re.sub('i.86', 'ix86', platformVersion)
extraLibName = os.environ['HOME'] + '/lib.' + osName + '.' + platformVersion

ccFlags = ['-O3', '-Wall', '-Wextra']

cEnvironment = Environment(tools=['gcc'])

cppFlags = ccFlags + ['-std=c++11']

cppEnvironment = Environment(tools=['g++', 'gnulink'])

microsecondTime = cEnvironment.Object('../Timing/microsecondTime.c', CFLAGS=ccFlags)
output = cppEnvironment.Object('output.cpp', CXXFLAGS=cppFlags)

def cppRule(globPattern, compiler='g++', cpppath=[], cxxflags=cppFlags, linkflags=[], libpath=[], libs=[]):
    for item in Glob(globPattern):
        executables.append(
            addCompileTarget(
                cppEnvironment.Program(
                    os.path.splitext(item.name)[0], [item.name, microsecondTime, output],
                    CXX=compiler, CPPPATH=['../Timing'] + cpppath, CXXFLAGS=cxxflags, LINKFLAGS=linkflags + ['-std=c++11'], LIBPATH=libpath, LIBS=libs)))

cppRule('pi_sequential*.cpp')
cppRule('pi_pthread*.cpp', libs=['pthread'])
cppRule('pi_mpi*.cpp', compiler='mpic++')  #  This MPI execution target runs things sequentially.  Use the command "mpirun -np N pi_c_mpi" to run the code on N processors.
cppRule('pi_openmp*.cpp', cxxflags=cppFlags + ['-fopenmp'], libs=['gomp'])  #  Assumes gcc is 4.2.0 or greater since that is when gomp was included.

cppRule('pi_cppcsp2.cpp', cpppath=[os.environ['HOME'] + '/include'], libpath=[extraLibName], libs=['cppcsp2', 'pthread'])

#  As from 2010-03-04 15:56+00:00, the Boost.MPI library is not in Lucid.  As is documented in the bug tracker
#  on Launchpad (https://bugs.launchpad.net/ubuntu/+source/boost-defaults/+bug/531973 and
#  https://bugs.launchpad.net/ubuntu/+source/boost1.42/+bug/582420), Boost.MPI has been ejected from
#  Ubuntu!!!!!!!!  It's still in Debian though :-))
#
#  If BOOST_HOME is set then use that otherwise use whatever is installed, if it is!
#
#  NB The MPI execution targets runs things sequentially.  Use the command "mpirun -np N pi_cpp_boostMPI" to
#  run the code on N processors.
try:
    boostHome = os.environ['BOOST_HOME']
    boostInclude = boostHome + '/include'
    boostLib = boostHome + '/lib'
    cppRule('pi_boostThread*.cpp', cpppath=[boostInclude], libpath=[boostLib], libs=['boost_thread'])
    cppRule('pi_boostMPI*.cpp', compiler='mpic++', cpppath=[boostInclude], libpath=[boostLib], libs=['boost_mpi', 'boost_serialization'])
except KeyError:
    if not os.path.isfile('/usr/lib/libboost_mpi.so'):
        print '\nWarning:  Cannot find a Boost.MPI.\n'
    else:
        cppRule('pi_boostThread*.cpp', libs=['boost_thread'])
        cppRule('pi_boostMPI*.cpp', compiler='mpic++', libs=['boost_mpi'])

#  Use Anthony Williams' Just::Thread library as an implementation of C++11 threads and things.  Anthony's
#  Ubuntu debs seems to work fine on Debian, which is good -- albeit lucky.
#cppRule('pi_cpp_justThread*.cpp', cpppath=['/usr/include/justthread'], libs=['justthread', 'rt'])
# Use Just::Thread Pro as it has the actor and dataflow support.
cppRule('pi_justThread*.cpp', cpppath=[extraLibName + '/JustThreadPro/include'], linkflags=['--static'], libpath=[extraLibName + '/JustThreadPro/libs'], libs=['justthread', 'pthread', 'rt'])

#  TBB 4.0 is packaged in Debian Unstable. Deal with the situation of TBB_HOME being defined for a custom
#  variant of TBB.  TBB only provides dynamic libraries, there are no static libraries, so we have to get
#  into the hassle of specifying a LD_LIBRARY_PATH to run the constructed executable if the TBB libraries
#  are not in the standard path :-( "LD_LIBRARY_PATH=$TBB_HOME pi_cpp_tbb . . . "
try:
    tbbHome = os.environ['TBB_HOME']
    cppRule('pi_tbb*.cpp', cpppath=[tbbHome + '/include'], libpath=[tbbHome], libs=['tbb'])
except KeyError:
    cppRule('pi_tbb*.cpp', libs=['tbb'])


for item in executables:
    addRunTarget(Command('run_' + item[0].name, item, './' + item[0].name))

Help(createHelp())
