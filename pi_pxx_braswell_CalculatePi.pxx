# -*- mode:perl; coding:utf-8; -*-

#  Calculation of Pi using quadrature. Parallel algorithms coded in Hyper-Werx Par++ for Raptor Live.
#
#  Copyright Â© 2009 Russel Winder, William Braswell Jr.

n = 500 ; # needs to be small until new C++ engine is complete
delta = 1.0 / n ;

chunk_start( 1, 2 ) ; #chunk operators are used for keeping track of progress, reported back in the GUI. 2 Pi calculations are done below in separate implementations, each encompassing 50% of the complete run.

#------Implementation #1------
accumulator = CalculatePi( n ) ; #Moved bulk of pi calculation work into a function, as its best to keep heavily modified variables out of global scope
pi = 4.0 * accumulator * delta ;
print ( "==== Par++ pi Approach #1\n" ) ;
print ( "==== Par++ pi = " , pi, "\n" ) ;
print ( "==== Par++ iteration count = " , n, "\n" ) ;

sub CalculatePi( NumIterations )
{
	#Code used to keep track of progress
	chunk_start( 1, 11 ) ;
	chunk_auto( 1 ) ;

	#Calculate pi
	x = range( 1, NumIterations ) ; #Makes an array of [1, 2, 3, ..., n+1]
	x = ( x - 0.5 ) * delta ; #Each operation ( + - * / ) in this and the next line parallelizes
	x = 1.0 / ( 1.0 + x * x ) ;
	accumulator_local = add( x ) ; #This add parallelizes too

	#Cleanup
	chunk_end( ) ;
	return( accumulator_local[0] ) ;
}

#------Implementation #2------
#Here is a second approach where CalculatePi parallelizes through only 1 function, and then an accumulator add
accumulator = CalculatePi2( n ) ;
pi = 4.0 * accumulator * delta ;
print ( "==== Par++ pi Approach #2\n" ) ;
print ( "==== Par++ pi = " , pi, "\n" ) ;
print ( "==== Par++ iteration count = " , n, "\n" ) ;

sub CalculatePi2( NumIterations )
{
	chunk_start( 1, NumIterations, 'CalculatePi' ) ;
	accumulator_local=add( CalculateX( @{ i=>0 }, param( range( 1, NumIterations ) ) ) ) ; #Only 1 primary paralellization occurs into CalculateX (besides the add at the end). Each CalculateX is ran on one Raptor Thread without further parallelizing.
	chunk_end( ) ;
	return( accumulator_local[0][0] ) ;
}

sub CalculateX( 0 x ) #This function doesn't parallelize further because, in this example, all received variables are non-array scalars
{
	x = ( x - 0.5 ) * delta ;
	x=1.0 / ( 1.0 + x * x ) ;
	chunk_progress( 1 ) ;
	return( x ) ;
}

chunk_end( ) ;